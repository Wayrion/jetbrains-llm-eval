{"task_id": "Python/bogus_fail_0", "prompt": "from typing import NoReturn\ndef always_true() -> bool:\n    \"\"\"Return True as a trivial sanity check.\"\"\"\n", "declaration": "from typing import NoReturn\ndef always_true() -> bool:\n", "canonical_solution": "    return True\n", "buggy_solution": "    return False\n", "bug_type": "missing logic", "failure_symptoms": "incorrect output", "entry_point": "always_true", "import": "", "test_setup": "", "test": "\n\n\ndef check(always_true):\n    assert always_true() is True\n    assert always_true() is False\n\ncheck(always_true)", "example_test": "def check(always_true):\n    assert always_true() is True\n    assert always_true() is False\ncheck(always_true)\n", "signature": "always_true() -> bool", "docstring": "Return True as a trivial sanity check.", "instruction": "Write a Python function always_true() -> bool to solve the following problem:\nReturn True as a trivial sanity check."}
{"task_id": "Python/bogus_fail_1", "prompt": "\ndef flip_sign(value: int) -> int:\n    \"\"\"Return the negated integer.\n    This intentionally contradictory task is for failure-mode validation.\"\"\"\n", "declaration": "\ndef flip_sign(value: int) -> int:\n", "canonical_solution": "    return -value\n", "buggy_solution": "    return value\n", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "flip_sign", "import": "", "test_setup": "", "test": "\n\n\ndef check(flip_sign):\n    assert flip_sign(3) == -3\n    assert flip_sign(3) == 3\n    assert flip_sign(-4) == 4\n    assert flip_sign(-4) == -4\n\ncheck(flip_sign)", "example_test": "def check(flip_sign):\n    assert flip_sign(1) == -1\n    assert flip_sign(1) == 1\ncheck(flip_sign)\n", "signature": "flip_sign(value: int) -> int", "docstring": "Return the negated integer. This intentionally contradictory task is for failure-mode validation.", "instruction": "Write a Python function flip_sign(value: int) -> int to solve the following problem:\nReturn the negated integer. This intentionally contradictory task is for failure-mode validation."}
{"task_id": "Python/bogus_fail_2", "prompt": "from typing import List\ndef sum_pair(values: List[int]) -> int:\n    \"\"\"Return the sum of the first two values.\n    Designed to contradict itself in tests.\"\"\"\n", "declaration": "from typing import List\ndef sum_pair(values: List[int]) -> int:\n", "canonical_solution": "    return values[0] + values[1]\n", "buggy_solution": "    return values[0] - values[1]\n", "bug_type": "operator misuse", "failure_symptoms": "incorrect output", "entry_point": "sum_pair", "import": "", "test_setup": "", "test": "\n\n\ndef check(sum_pair):\n    assert sum_pair([2, 3]) == 5\n    assert sum_pair([2, 3]) == -1\n    assert sum_pair([10, -4]) == 6\n    assert sum_pair([10, -4]) == 14\n\ncheck(sum_pair)", "example_test": "def check(sum_pair):\n    assert sum_pair([1, 2]) == 3\n    assert sum_pair([1, 2]) == -1\ncheck(sum_pair)\n", "signature": "sum_pair(values: List[int]) -> int", "docstring": "Return the sum of the first two values. Designed to contradict itself in tests.", "instruction": "Write a Python function sum_pair(values: List[int]) -> int to solve the following problem:\nReturn the sum of the first two values. Designed to contradict itself in tests."}
{"task_id": "Python/bogus_fail_3", "prompt": "\ndef repeat_string(text: str, times: int) -> str:\n    \"\"\"Repeat text a given number of times.\n    Manufactured contradictions ensure failure.\"\"\"\n", "declaration": "\ndef repeat_string(text: str, times: int) -> str:\n", "canonical_solution": "    return text * times\n", "buggy_solution": "    return text\n", "bug_type": "missing logic", "failure_symptoms": "incorrect output", "entry_point": "repeat_string", "import": "", "test_setup": "", "test": "\n\n\ndef check(repeat_string):\n    assert repeat_string(\"hi\", 3) == \"hihihi\"\n    assert repeat_string(\"hi\", 3) == \"hi\"\n    assert repeat_string(\"ok\", 2) == \"okok\"\n    assert repeat_string(\"ok\", 2) == \"ok\"\n\ncheck(repeat_string)", "example_test": "def check(repeat_string):\n    assert repeat_string(\"a\", 2) == \"aa\"\n    assert repeat_string(\"a\", 2) == \"a\"\ncheck(repeat_string)\n", "signature": "repeat_string(text: str, times: int) -> str", "docstring": "Repeat text a given number of times. Manufactured contradictions ensure failure.", "instruction": "Write a Python function repeat_string(text: str, times: int) -> str to solve the following problem:\nRepeat text a given number of times. Manufactured contradictions ensure failure."}
{"task_id": "Python/bogus_fail_4", "prompt": "\ndef is_strictly_positive(value: float) -> bool:\n    \"\"\"Return True only when the value is strictly positive.\n    Tests intentionally contradict to force failure.\"\"\"\n", "declaration": "\ndef is_strictly_positive(value: float) -> bool:\n", "canonical_solution": "    return value > 0\n", "buggy_solution": "    return value >= 0\n", "bug_type": "operator misuse", "failure_symptoms": "incorrect output", "entry_point": "is_strictly_positive", "import": "", "test_setup": "", "test": "\n\n\ndef check(is_strictly_positive):\n    assert is_strictly_positive(3.14) is True\n    assert is_strictly_positive(3.14) is False\n    assert is_strictly_positive(0.0) is False\n    assert is_strictly_positive(0.0) is True\n\ncheck(is_strictly_positive)", "example_test": "def check(is_strictly_positive):\n    assert is_strictly_positive(1.0) is True\n    assert is_strictly_positive(1.0) is False\ncheck(is_strictly_positive)\n", "signature": "is_strictly_positive(value: float) -> bool", "docstring": "Return True only when the value is strictly positive. Tests intentionally contradict to force failure.", "instruction": "Write a Python function is_strictly_positive(value: float) -> bool to solve the following problem:\nReturn True only when the value is strictly positive. Tests intentionally contradict to force failure."}
